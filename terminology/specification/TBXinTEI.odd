<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="PureOdd.rnc" type="application/relax-ng-compact-syntax"?>
<TEI xml:lang="en" xmlns="http://www.tei-c.org/ns/1.0"
  xmlns:tbx="http://www.tbx.org" xmlns:sch="http://www.ascc.net/xml/schematron">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>TBX Extension to TEI</title>
        <author>Laurent Romary</author>
        <author>Stefan Pernes</author>
      </titleStmt>
      <publicationStmt>
        <authority>Inria</authority>
        <availability status="free">
          <p>This document is intended to be submitted as a new chapter of the TEI guidelines. It
            can be thus disseminated as widely as necessary, but please contact the author if you
            want to fork it with modifications, so that these can be included in any future version.</p>
          <licence
            target="http://creativecommons.org/licenses/by/3.0/">
            <p>The Creative Commons Attribution 3.0 Unported (CC BY 3.0) Licence
              applies to this document.</p>
            <p>You can quote this document as: <q>Romary, L., TBX extension to TEI; ODD specification. 2014</q></p>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>COMMITTEE DRAFT ISO/CD 30042 (N 1097)</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <div>
        <head>Modeling Onomasiological Data</head>
        <div>
          <p>...</p>
        </div>
      </div>
      <div>
        <schemaSpec ident="TBXinTEI" start="TEI teiCorpus">
          <moduleRef key="tei"/>
          <moduleRef key="header"/>
          <moduleRef key="core"/>
          <moduleRef key="textstructure" include="TEI text body div front back floatingText"/>
          <moduleRef key="dictionaries" except="def"/>
          
          <specGrpRef target="#spec-term-entries"/>
          <specGrpRef target="#spec-equiv"/>
        </schemaSpec>
          
        <specGrp xml:id="spec-term-entries">
          <!-- Elements needed for terminological entries -->
          
          <elementSpec ident="conceptEntry">
            <!-- based on superEntry -->
            <desc>The root element of a terminological entry. It shall contain at least one language section.</desc> 
            <equiv name="tbx:conceptEntry"/>
            <classes>
              <memberOf key="att.global"/>
              <memberOf key="att.entryLike"/>
              <memberOf key="att.sortable"/>
              <memberOf key="model.entryLike"/>
            </classes>
            <content>
              <alternate minOccurs="1" maxOccurs="unbounded">
                <elementRef key="descrip" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="descripGrp" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="transacGrp" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="langSec" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="etym" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="floatingText" minOccurs="0" maxOccurs="unbounded"/>
                <elementRef key="model.entryPart.top"/>
              </alternate>
            </content>
            <exemplum xml:lang="en">
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <conceptEntry/>
              </egXML>
            </exemplum>
            <remarks><p>...</p></remarks>
          </elementSpec>

          <elementSpec ident="langSec">
            <!-- based on entry -->
            <desc>A nesting element that contains all the information in a terminological entry pertaining to one language, including all the <gi>termSec</gi> elements (terms and
              associated information) for that language.</desc>
            <equiv name="tbx:langSec"/>
            <classes>
              <memberOf key="att.global"/>
            </classes>
            <content>
              <alternate minOccurs="1" maxOccurs="unbounded">
                <elementRef key="descrip"/>
                <elementRef key="descripGrp"/>
                <elementRef key="transacGrp"/>
                <elementRef key="termSec"/>
                <elementRef key="model.entryPart"/>
                <elementRef key="model.global"/>
                <elementRef key="model.ptrLike"/>
              </alternate>
            </content>
            <attList>
              <attDef ident="xml:lang" usage="req" mode="change"/>
            </attList>
            <exemplum xml:lang="en">
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <langSec xml:lang="en"/>
              </egXML>
            </exemplum>
          </elementSpec>
          
          <elementSpec ident="termSec">
            <!-- based on form -->
            <desc>A <emph>term information group</emph>. A grouping element that contains child elements describing a term. It is often referred to as the <emph>term section</emph>.</desc>
            <equiv name="tbx:termSec"/>
            <classes>
              <memberOf key="att.global"/>
              <memberOf key="att.lexicographic"/>
            </classes>
            <content>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <textNode/>
                <elementRef key="descrip"/>
                <elementRef key="descripGrp"/>
                <elementRef key="transacGrp"/>
                <elementRef key="model.gLike"/>
                <elementRef key="model.phrase"/>
                <elementRef key="model.inter"/>
                <elementRef key="model.formPart"/>
                <elementRef key="model.global"/>
              </alternate>
            </content>
            <attList>
              <attDef ident="type" usage="opt">
                <valList type="open">
                  <valItem ident="simple"/>
                  <valItem ident="lemma">
                    <equiv name="tbx:lemma"/>
                  </valItem>
                  <valItem ident="variant">
                    <equiv name="tbx:termType"/> <!-- termType:variant -->
                  </valItem>
                  <valItem ident="compound"/>
                  <valItem ident="derivative"/>
                  <valItem ident="inflected"/>
                  <valItem ident="phrase"/>
                  <valItem ident="full">
                    <equiv name="tbx:termType"/> <!-- termType:fullForm -->
                  </valItem>
                  <valItem ident="abbrev">
                    <equiv name="tbx:abbreviatedFormFor"/>
                  </valItem>
                </valList>
              </attDef>
            </attList>
            <exemplum xml:lang="en">
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <termSec type="compound"/>
              </egXML>
            </exemplum>
          </elementSpec>
          
         <elementSpec ident="descrip">
           <desc>An element that contains descriptive information about a concept, or relations to other concepts. The type of information that the element contains, and any restrictions
             on the permissible values of the element, are determined by the value of the <att>type</att> attribute.</desc>
              <classes>
                <memberOf key="att.global"/>
              </classes>
              <content>
                <alternate minOccurs="0" maxOccurs="unbounded">
                  <elementRef key="model.entryPart"/>
                  <elementRef key="model.entryPart.top"/>
                  <elementRef key="model.limitedPhrase"/>
                  <textNode/>
                </alternate>
              </content>
              <constraintSpec scheme="schematron" ident="descrip">
                  <constraint>
                      <sch:pattern name="descrip_antonymConcept">
                          <sch:rule context="descrip[@type='antonymConcept']">
                              <sch:assert test="(.=not(*[not(local-name()='hi')]))and(parent::conceptEntry or parent::descripGrp/parent::conceptEntry)">Antonym concepts should occur at the
                                  entry (concept) level. The antonym-concept in this element must be expressed in basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_associatedConcept">
                          <sch:rule context="descrip[@type='associatedConcept']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')]))and (parent::conceptEntry or parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec)"
                                  >Associated concepts should occur at the conceptEntry or the langSec level. The term in this element must be expressed in basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_audio">
                          <sch:rule context="descrip[@type='audio']">
                              <sch:assert
                                  test="(.=not(*))and (parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec)"
                                  >The content of this element must be plain text. It can occur at the concept (conceptEntry) level, the langSec level or the term (termSec)
                                  level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_broaderConceptGeneric">
                          <sch:rule context="descrip[@type='broaderConceptGeneric']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::conceptEntry or parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec)"
                                  >Generic broader concepts should occur at the conceptEntry level or the langSec level. The term in this element must be expressed in basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_broaderConceptPartitive">
                          <sch:rule context="descrip[@type='broaderConceptPartitive']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::conceptEntry or parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec)"
                                  >Partitive broader concepts should occur at the conceptEntry level or the langSec level. The term in this element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_characteristic">
                          <sch:rule context="descrip[@type='characteristic']">
                              <sch:assert test="(.=not(*))and (parent::termSec or parent::descripGrp/parent::termSec)">A characteristic should only occur at the term (termSec) level. The
                                  content of this element must be plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_classificationCode">
                          <sch:rule context="descrip[@type='classificationCode']">
                              <sch:assert
                                  test="(.=not(*)) and (parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec)"
                                  > The content of this element must be plainText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_conceptPosition">
                          <sch:rule context="descrip[@type='conceptPosition']">
                              <sch:assert test="(.=not(*)) and (parent::conceptEntry or parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec)">
                                  Information about a concept position should occur at the conceptEntry level or the langSec level, and it must be expressed in plainText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_coordinateConceptGeneric">
                          <sch:rule context="descrip[@type='coordinateConceptGeneric']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::conceptEntry or parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec)"
                                  >Generic coordinate concepts should occur at the conceptEntry level or the langSec level. The term in this element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_coordinateConceptPartitive">
                          <sch:rule context="descrip[@type='coordinateConceptPartitive']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::conceptEntry or parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec)"
                                  >Partitive coordinate concepts should occur at the conceptEntry level or the langSec level. The term in this element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_context">
                          <sch:rule context="descrip[@type='context']">
                              <sch:assert test="parent::termSec or parent::descripGrp/parent::termSec">A context sentence can only occur at the term (termSec) level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_definition">
                          <sch:rule context="descrip[@type='definition']">
                              <sch:assert
                                  test="parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec"
                                  > A definition must occur at the conceptEntry level, the langSec level, or the term (termSec) level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_example">
                          <sch:rule context="descrip[@type='example']">
                              <sch:assert
                                  test="parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec"
                                  > An example must occur at the conceptEntry level, the langSec level, or the term (termSec) level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_explanation">
                          <sch:rule context="descrip[@type='explanation']">
                              <sch:assert
                                  test="parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec"
                                  > An explanation must occur at the conceptEntry level, the langSec level, or the term (termSec) level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_figure">
                          <sch:rule context="descrip[@type='figure']">
                              <sch:assert
                                  test="(.=not(*)) and (parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec)"
                                  > The content of this element must be plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_otherBinaryData">
                          <sch:rule context="descrip[@type='otherBinaryData']">
                              <sch:assert
                                  test="(.=not(*)) and (parent::conceptEntry or parent::langSec or parent::termSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::termSec)"
                                  >The content of this element must be plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_quantity">
                          <sch:rule context="descrip[@type='quantity']">
                              <sch:assert test="(.=not(*)) and (parent::termSec or parent::descripGrp/parent::termSec)">A quantity should occur at the term (termSec) level. The content of
                                  this element must be plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_range">
                          <sch:rule context="descrip[@type='range']">
                              <sch:assert test="(.=not(*)) and (parent::termSec or parent::descripGrp/parent::termSec)">A range should occur at the term (termSec) level. The content of this
                                  element must be plainText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_relatedConcept">
                          <sch:rule context="descrip[@type='relatedConcept']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Related concepts should occur at the conceptEntry level or the langSec level. The content of this element must be expressed in basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_relatedConceptBroader">
                          <sch:rule context="descrip[@type='relatedConceptBroader']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')]) )and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Broader related concepts should occur at the conceptEntry level or the langSec level. The content of this element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_relatedConceptNarrower">
                          <sch:rule context="descrip[@type='relatedConceptNarrower']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Narrower related concepts should occur at the conceptEntry level or the langSec level. The content of this element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_reliabilityCode">
                          <sch:rule context="descrip[@type='reliabilityCode']">
                              <sch:assert
                                  test="((.='1' or .='2' or .='3' or .='4' or .='5' or .='6' or .='7' or .='8' or .='9' or .='10') and (parent::langSec or parent::conceptEntry or parent::termSec or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::termSec))"
                                  >A reliability code can be a value from 1 (least reliable) to 10 (most reliable).</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_sampleSentence">
                          <sch:rule context="descrip[@type='sampleSentence']">
                              <sch:assert test="parent::termSec or parent::descripGrp/parent::termSec"> A sample sentence can only occur at the term (termSec) level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_sequentiallyRelatedConcept">
                          <sch:rule context="descrip[@type='sequentiallyRelatedConcept']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Sequentially related concepts should occur at the conceptEntry level or the langSec level. The content of this element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_spatiallyRelatedConcept">
                          <sch:rule context="descrip[@type='spatiallyRelatedConcept']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Spatially related concepts should occur at the conceptEntry level or the langSec level. The content of the element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_subjectField">
                          <sch:rule context="descrip[@type='subjectField']">
                              <sch:assert test="(.=not(*)) and (parent::conceptEntry or parent::descripGrp/parent::conceptEntry)"> A subject field must be a plainText value. Subject fields
                                  usually occur at the conceptEntry level.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_subordinateConceptGeneric">
                          <sch:rule context="descrip[@type='subordinateConceptGeneric']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  > Generic subordinate concepts should occur at the conceptEntry level or the langSec level. The content of the element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_subordinateConceptPartitive">
                          <sch:rule context="descrip[@type='subordinateConceptPartitive']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  > Partitive subordinate concepts should occur at the conceptEntry level or the langSec level. The content of the element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_superordinateConceptGeneric">
                          <sch:rule context="descrip[@type='superordinateConceptGeneric']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Generic superordinate concepts should occur at the conceptEntry level or the langSec level. The content of the element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_superordinateConceptPartitive">
                          <sch:rule context="descrip[@type='superordinateConceptPartitive']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Partitive superordinate concepts should occur at the conceptEntry level or the langSec level. The content of the element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_table">
                          <sch:rule context="descrip[@type='table']">
                              <sch:assert
                                  test="(.=not(*)) and (parent::langSec or parent::conceptEntry or parent::termSec or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::termSec)"
                                  > The content of this element must be plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_temporallyRelatedConcept">
                          <sch:rule context="descrip[@type='temporallyRelatedConcept']">
                              <sch:assert
                                  test="(.=not(*[not(local-name()='hi')])) and (parent::langSec or parent::conceptEntry or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry)"
                                  >Temporally related concepts should occur at the conceptEntry level or the langSec level. The content of the element must be expressed in
                                  basicText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_thesaurusDescriptor">
                          <sch:rule context="descrip[@type='thesaurusDescriptor']">
                              <sch:assert test="(.=not(*)) and (parent::conceptEntry or parent::descripGrp/parent::conceptEntry)">Thesaurus descriptors should occur at the conceptEntry
                                  level. The content of this element must be plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_unit">
                          <sch:rule context="descrip[@type='unit']">
                              <sch:assert test="(not (*) and (parent::termSec or parent::descripGrp/parent::termSec))"> Units should occur at the term (termSec) level. Units must be
                                  expressed in plainText.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descrip_video">
                          <sch:rule context="descrip[@type='video']">
                              <sch:assert
                                  test="(.=not(*)) and (parent::langSec or parent::conceptEntry or parent::termSec or parent::descripGrp/parent::langSec or parent::descripGrp/parent::conceptEntry or parent::descripGrp/parent::termSec)"
                                  >The content of this element must be in plain text.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                  </constraint>
              </constraintSpec>
              <attList>
                <attDef ident="type" usage="req">
                    <desc>Indicates the data-category type of the <gi>descrip</gi> element, such as <val>definition</val> or <val>associated-concept</val>.</desc>
                    <datatype>
                        <dataRef key="teidata.text"/>
                    </datatype>
                </attDef>
                <attDef ident="source" usage="opt" mode="change">
                  <equiv name="tbx:xSource"/>
                </attDef>
                <attDef ident="url" usage="opt">
                  <datatype>
                    <dataRef key="teidata.pointer"/>
                  </datatype>
                </attDef>
                <attDef ident="target">
                  <datatype>
                    <dataRef key="teidata.text"/>
                  </datatype>
                </attDef>
              </attList>
          </elementSpec>

          <elementSpec ident="descripGrp">
              <desc>Contains one <gi>descrip</gi> element as well as additional child elements for associated administrative information.</desc>
              <classes>
                <memberOf key="att.global"/>
              </classes>
              <content>
                <elementRef key="descrip"/>
                <alternate minOccurs="0" maxOccurs="unbounded">
                    <elementRef key="descripNote"/>
                    <elementRef key="transacGrp"/>
                    <elementRef key="note"/>
                    <classRef key="model.ptrLike"/>
                </alternate>
              </content>
          </elementSpec>

          <elementSpec ident="descripNote">
              <desc>Element used to indicate the type of definition or context with which it is associated.</desc>
              <classes>
                <memberOf key="att.global"/>
              </classes>
              <content>
                  <textNode/>
              </content>
              <constraintSpec scheme="schematron" ident="descripNote">
                  <constraint>
                      <sch:pattern name="descripNote_contextType">
                          <sch:rule context="descripNote[@type='contextType']">
                              <sch:assert
                                  test=". ='definingContext' 
                                  or .='explanatoryContext' 
                                  or .='associativeContext' 
                                  or .='linguisticContext' 
                                  or .='metalinguisticContext' 
                                  or .='translatedContext'"
                                  > Contexts can only be of one of the following types: definingContext, explanatoryContext, associativeContext, linguisticContext, metalinguisticContext or
                                  translatedContext.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                      <sch:pattern name="descripNote_definitionType">
                          <sch:rule context="descripNote[@type='definitionType']">
                              <sch:assert
                                  test=".=
                                  'intensionalDefinition' or .='extensionalDefinition' or .='partitiveDefinition' or .='translatedDefinition'"
                                  > Definitions can only be of one of the following types: intensionalDefinition, extensionalDefinition, partitiveDefinition, or
                                  translatedDefinition.</sch:assert>
                          </sch:rule>
                      </sch:pattern>
                  </constraint>
              </constraintSpec>
              <attList>
                  <attDef ident="type" usage="req">
                      <desc>Indicates the data-category type of the <gi>descripNote</gi> element, such as <val>contextType</val>.</desc>
                      <datatype>
                          <dataRef key="teidata.text"/>
                      </datatype>
                  </attDef>
              </attList>
          </elementSpec>
          
         <elementSpec ident="transac">
            <desc>A record that indicates the stage of the entry within the overal process of creation, approval, and use of a terminology entry. Currently this element is only used to
              specify the type of transaction, and therefore only one value is currently specified for the <att>type</att> attribute. However, additional <att>type</att> attribute values
              can be defined for additional purposes in a user-specific XCS file.</desc>
            <classes>
              <memberOf key="att.global"/>
            </classes>
            <content>
              <textNode/>
            </content>
            <constraintSpec scheme="schematron" ident="transac">
              <constraint>
                <sch:pattern name="transac_transactionType">
                  <sch:rule context="transac[@type='transactionType']">
                    <sch:assert
                      test=". =
                      'origination' or .='input' or .='modification' or .='check' or .='approval' or 
                      .='withdrawl' or .='standardization' or .='exportation' or .='importation' or .='proposal' or .='userAccess'"
                      >The content of this element indicates the type of transaction and must be one of the following values: origination, input, modification, check, approval,
                      withdrawal, standardization, exportation, importation, proposal, userAccess. </sch:assert>
                  </sch:rule>
                </sch:pattern>
              </constraint>
            </constraintSpec>
            <attList>
              <attDef ident="type" usage="req">
                <desc>The attribute value <val>transactionType</val> ensures that the content of the <gi>transac</gi> element will be a transaction type.</desc>
                <datatype>
                  <dataRef key="teidata.text"/>
                </datatype>
              </attDef>
              
            </attList>
          </elementSpec>
          
          <elementSpec ident="transacGrp">
            <desc>An element that includes child elements that provide information about a transaction. </desc>
            <classes>
              <memberOf key="att.global"/>
            </classes>
            <content>
              <alternate>
                <sequence>
                  <elementRef key="transac"/>
                  <alternate minOccurs="0" maxOccurs="unbounded">
                    <elementRef key="transacNote"/>
                    <elementRef key="date"/>
                    <elementRef key="note"/>
                    <classRef key="model.ptrLike"/>
                  </alternate>
                </sequence>
              </alternate>
            </content>
          </elementSpec>
          
          <elementSpec ident="transacNote">
            <desc>Information about a transaction, such as the name of the person who performed the transaction. The content of this element shall be plainText.</desc>
            <classes>
              <memberOf key="att.global"/>
            </classes>
            <content>
              <textNode/>
            </content>
            <attList>
              <attDef ident="type" usage="req">
                <datatype>
                  <dataRef key="teidata.text"/>
                </datatype>
              </attDef>
            </attList>
          </elementSpec>
        </specGrp>
          
        <specGrp xml:id="spec-equiv">
          <!-- Additional definitions of TBX equivalents for TEI constructs -->
          
          <elementSpec ident="abbr" module="core" mode="change">
            <equiv name="tbx:termType"/> <!-- termType:abbreviation -->
            <attList>
              <attDef ident="type" mode="change">
                <valList type="open">
                  <valItem ident="suspension">
                    <equiv name="tbx:termType"/> <!-- termType:clippedTerm -->
                  </valItem>
                  <valItem ident="contraction"/>
                  <valItem ident="brevigraph">
                    <equiv name="tbx:termType"/> <!-- termType:symbol -->
                  </valItem>
                  <valItem ident="superscription"/>
                  <valItem ident="acronym">
                    <equiv name="tbx:termType"/> <!-- termType:acronym -->
                  </valItem>
                  <valItem ident="title"/>
                  <valItem ident="organization"/>
                  <valItem ident="geographic"/>
                </valList>
              </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="bibl" module="core" mode="change">
            <equiv name="tbx:source"/>
          </elementSpec>
          
          <elementSpec ident="date" module="core" mode="change">
            <equiv name="tbx:date"/>
          </elementSpec>
          
          <elementSpec ident="def" module="dictionaries" mode="change">
            <equiv name="tbx:definition"/>
          </elementSpec>
          
          <elementSpec ident="etym" module="dictionaries" mode="change">
            <equiv name="tbx:etymology"/>
          </elementSpec>
          
          <elementSpec ident="foreign" module="core" mode="change">
            <equiv name="tbx:foreign"/>
          </elementSpec>
          
          <elementSpec ident="formula" module="core" mode="change">
            <equiv name="tbx:math"/>
            <attList>
              <attDef ident="notation" usage="opt" mode="change">
                <valList type="open">
                  <valItem ident="mathml">
                    <equiv name="tbx:xMathML"/>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="gram" module="dictionaries" mode="change">
            <attList>
              <attDef ident="type" usage="opt" mode="change">
                <valList type="closed">
                  <valItem ident="pos">
                    <equiv name="tbx:partOfSpeech"/>
                  </valItem>
                  <valItem ident="gen">
                    <equiv name="tbx:grammaticalGender"/>
                  </valItem>
                  <valItem ident="num">
                    <equiv name="tbx:grammaticalNumber"/>
                  </valItem>
                  <valItem ident="animate">
                    <equiv name="tbx:animacy"/>
                  </valItem>
                  <valItem ident="proper"/>
                </valList>
              </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="hi" module="core" mode="change">
            <equiv name="tbx:hi"/>
            <attList>
              <attDef ident="rend" usage="opt" mode="change">
                <valList type="open">
                  <valItem ident="bold">
                    <equiv name="tbx:bold"/>
                  </valItem>
                  <valItem ident="italic">
                    <equiv name="tbx:italics"/>
                  </valItem>
                  <valItem ident="subscript">
                    <equiv name="tbx:subscript"/>
                  </valItem>
                  <valItem ident="superscript">
                    <equiv name="tbx:superscript"/>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="hom" module="dictionaries" mode="change">
            <equiv name="tbx:homograph"/>
          </elementSpec>
          
          <elementSpec ident="hyph" module="dictionaries" mode="change">
            <equiv name="tbx:hyphenation"/>
          </elementSpec>
          
          <elementSpec ident="m" module="analysis" mode="change">
            <equiv name="tbx:morphologicalElement"/>
          </elementSpec>
          
          <elementSpec ident="media" module="core" mode="change">
            <equiv name="tbx:xAudio"/>
            <equiv name="tbx:xGraphic"/>
            <equiv name="tbx:xVideo"/>
          </elementSpec>
          
          <elementSpec ident="mentioned" module="core" mode="change">
            <equiv name="tbx:entailedTerm"/>
          </elementSpec>
          
          <elementSpec ident="note" module="core" mode="change">
            <equiv name="tbx:note"/>
          </elementSpec>
          
          <elementSpec ident="orth" module="dictionaries" mode="change">
            <equiv name="tbx:term"/>
            <attList>
              <attDef ident="type" usage="opt" mode="change">
                <valList type="open">
                  <valItem ident="transliterated">
                    <equiv name="tbx:termType"/> <!-- termType:transliteratedForm -->
                  </valItem>
                </valList>
              </attDef>
              <attDef ident="orig" usage="opt" mode="change">
                <equiv name="tbx:termType"/> <!-- termType:transcribedForm -->
              </attDef>
            </attList>
          </elementSpec>
 
          <elementSpec ident="pron" module="dictionaries" mode="change">
            <equiv name="tbx:pronunciation"/>
          </elementSpec>
          
          <elementSpec ident="ptr" module="core" mode="change">
            <equiv name="tbx:externalCrossReference"/>
          </elementSpec>
          
          <elementSpec ident="ref" module="core" mode="change">
            <equiv name="tbx:crossReference"/>
          </elementSpec>
          
          <elementSpec ident="syll" module="dictionaries" mode="change">
            <equiv name="tbx:syllabification"/>
          </elementSpec>
          
          <elementSpec ident="tag" module="tagdocs" mode="change">
            <attList>
              <attDef ident="type" usage="opt" mode="change">
                <valList type="closed">
                  <valItem ident="start">
                    <equiv name="tbx:sc"/>
                  </valItem>
                  <valItem ident="end">
                    <equiv name="tbx:ec"/>
                  </valItem>
                  <valItem ident="empty">
                    <equiv name="tbx:ph"/>
                  </valItem>
                  <valItem ident="pi"/>
                  <valItem ident="comment"/>
                  <valItem ident="ms"/>
                </valList>
              </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="usg" module="dictionaries" mode="change">
            <attList>
              <attDef ident="type" usage="opt" mode="change">
                <valList type="closed">
                  <valItem ident="geo">
                    <equiv name="tbx:geographicalUsage"/>
                  </valItem>
                  <valItem ident="time">
                    <equiv name="tbx:temporalQualifier"/>
                  </valItem>
                  <valItem ident="dom"/>
                  <valItem ident="register">
                    <equiv name="tbx:register"/>
                  </valItem>
                  <valItem ident="style"/>
                  <valItem ident="plev"/>
                  <valItem ident="lang"/>
                  <valItem ident="gram"/>
                  <valItem ident="syn">
                    <equiv name="tbx:termType"/> <!-- termType:synonym, synonymousPhrase -->
                  </valItem>
                  <valItem ident="hyper"/>
                  <valItem ident="colloc"/>
                  <valItem ident="comp"/>
                  <valItem ident="obj"/>
                  <valItem ident="subj"/>
                  <valItem ident="verb"/>
                  <valItem ident="hint"/>
                  <!-- the following are not TEI presets -->
                  <valItem ident="directionality">
                    <equiv name="tbx:directionality"/>
                  </valItem>
                  <valItem ident="frequency">
                    <equiv name="tbx:frequency"/>
                  </valItem>
                  <valItem ident="ant">
                    <equiv name="tbx:antonymTerm"/>
                  </valItem>
                  <valItem ident="ff">
                    <equiv name="tbx:falseFriend"/>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="xr" module="dictionaries" mode="change">
            <equiv name="tbx:see"/>
          </elementSpec>

        </specGrp>

      </div>
    </body>
  </text>
</TEI>
